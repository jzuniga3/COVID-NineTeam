{"ast":null,"code":"import { canUseDOM } from 'fbjs/lib/ExecutionEnvironment';\nimport createResponderEvent from \"./createResponderEvent\";\nimport { isCancelish, isEndish, isMoveish, isScroll, isSelectionChange, isStartish } from \"./ResponderEventTypes\";\nimport { getLowestCommonAncestor, getResponderPaths, hasTargetTouches, hasValidSelection, isPrimaryPointerDown, setResponderId } from \"./utils\";\nimport ResponderTouchHistoryStore from \"./ResponderTouchHistoryStore\";\nvar emptyObject = {};\nvar startRegistration = ['onStartShouldSetResponderCapture', 'onStartShouldSetResponder', {\n  bubbles: true\n}];\nvar moveRegistration = ['onMoveShouldSetResponderCapture', 'onMoveShouldSetResponder', {\n  bubbles: true\n}];\nvar scrollRegistration = ['onScrollShouldSetResponderCapture', 'onScrollShouldSetResponder', {\n  bubbles: false\n}];\nvar shouldSetResponderEvents = {\n  touchstart: startRegistration,\n  mousedown: startRegistration,\n  touchmove: moveRegistration,\n  mousemove: moveRegistration,\n  scroll: scrollRegistration\n};\nvar emptyResponder = {\n  id: null,\n  idPath: null,\n  node: null\n};\nvar responderListenersMap = new Map();\nvar isEmulatingMouseEvents = false;\nvar trackedTouchCount = 0;\nvar currentResponder = {\n  id: null,\n  node: null,\n  idPath: null\n};\n\nfunction changeCurrentResponder(responder) {\n  currentResponder = responder;\n}\n\nfunction getResponderConfig(id) {\n  var config = responderListenersMap.get(id);\n  return config != null ? config : emptyObject;\n}\n\nfunction eventListener(domEvent) {\n  var eventType = domEvent.type;\n  var eventTarget = domEvent.target;\n\n  if (eventType === 'touchstart') {\n    isEmulatingMouseEvents = true;\n  }\n\n  if (eventType === 'touchmove' || trackedTouchCount > 1) {\n    isEmulatingMouseEvents = false;\n  }\n\n  if (eventType === 'mousedown' && isEmulatingMouseEvents || eventType === 'mousemove' && isEmulatingMouseEvents || eventType === 'mousemove' && trackedTouchCount < 1) {\n    return;\n  }\n\n  if (isEmulatingMouseEvents && eventType === 'mouseup') {\n    if (trackedTouchCount === 0) {\n      isEmulatingMouseEvents = false;\n    }\n\n    return;\n  }\n\n  var isStartEvent = isStartish(eventType) && isPrimaryPointerDown(domEvent);\n  var isMoveEvent = isMoveish(eventType);\n  var isEndEvent = isEndish(eventType);\n  var isScrollEvent = isScroll(eventType);\n  var isSelectionChangeEvent = isSelectionChange(eventType);\n  var responderEvent = createResponderEvent(domEvent);\n\n  if (isStartEvent || isMoveEvent || isEndEvent) {\n    if (domEvent.touches) {\n      trackedTouchCount = domEvent.touches.length;\n    } else {\n      if (isStartEvent) {\n        trackedTouchCount = 1;\n      } else if (isEndEvent) {\n        trackedTouchCount = 0;\n      }\n    }\n\n    ResponderTouchHistoryStore.recordTouchTrack(eventType, responderEvent.nativeEvent);\n  }\n\n  var eventPaths = getResponderPaths(domEvent);\n  var wasNegotiated = false;\n  var wantsResponder;\n\n  if (isStartEvent || isMoveEvent || isScrollEvent && trackedTouchCount > 0) {\n    var currentResponderIdPath = currentResponder.idPath;\n    var eventIdPath = eventPaths.idPath;\n\n    if (currentResponderIdPath != null && eventIdPath != null) {\n      var lowestCommonAncestor = getLowestCommonAncestor(currentResponderIdPath, eventIdPath);\n\n      if (lowestCommonAncestor != null) {\n        var indexOfLowestCommonAncestor = eventIdPath.indexOf(lowestCommonAncestor);\n        var index = indexOfLowestCommonAncestor + (lowestCommonAncestor === currentResponder.id ? 1 : 0);\n        eventPaths = {\n          idPath: eventIdPath.slice(index),\n          nodePath: eventPaths.nodePath.slice(index)\n        };\n      } else {\n        eventPaths = null;\n      }\n    }\n\n    if (eventPaths != null) {\n      wantsResponder = findWantsResponder(eventPaths, domEvent, responderEvent);\n\n      if (wantsResponder != null) {\n        attemptTransfer(responderEvent, wantsResponder);\n        wasNegotiated = true;\n      }\n    }\n  }\n\n  if (currentResponder.id != null && currentResponder.node != null) {\n    var _currentResponder = currentResponder,\n        id = _currentResponder.id,\n        node = _currentResponder.node;\n\n    var _getResponderConfig = getResponderConfig(id),\n        onResponderStart = _getResponderConfig.onResponderStart,\n        onResponderMove = _getResponderConfig.onResponderMove,\n        onResponderEnd = _getResponderConfig.onResponderEnd,\n        onResponderRelease = _getResponderConfig.onResponderRelease,\n        onResponderTerminate = _getResponderConfig.onResponderTerminate,\n        onResponderTerminationRequest = _getResponderConfig.onResponderTerminationRequest;\n\n    responderEvent.bubbles = false;\n    responderEvent.cancelable = false;\n    responderEvent.currentTarget = node;\n\n    if (isStartEvent) {\n      if (onResponderStart != null) {\n        responderEvent.dispatchConfig.registrationName = 'onResponderStart';\n        onResponderStart(responderEvent);\n      }\n    } else if (isMoveEvent) {\n      if (onResponderMove != null) {\n        responderEvent.dispatchConfig.registrationName = 'onResponderMove';\n        onResponderMove(responderEvent);\n      }\n    } else {\n      var isTerminateEvent = isCancelish(eventType) || eventType === 'contextmenu' || eventType === 'blur' && eventTarget === window || eventType === 'blur' && eventTarget.contains(node) && domEvent.relatedTarget !== node || isScrollEvent && trackedTouchCount === 0 || isScrollEvent && eventTarget.contains(node) && eventTarget !== node || isSelectionChangeEvent && hasValidSelection(domEvent);\n      var isReleaseEvent = isEndEvent && !isTerminateEvent && !hasTargetTouches(node, domEvent.touches);\n\n      if (isEndEvent) {\n        if (onResponderEnd != null) {\n          responderEvent.dispatchConfig.registrationName = 'onResponderEnd';\n          onResponderEnd(responderEvent);\n        }\n      }\n\n      if (isReleaseEvent) {\n        if (onResponderRelease != null) {\n          responderEvent.dispatchConfig.registrationName = 'onResponderRelease';\n          onResponderRelease(responderEvent);\n        }\n\n        changeCurrentResponder(emptyResponder);\n      }\n\n      if (isTerminateEvent) {\n        var shouldTerminate = true;\n\n        if (eventType === 'contextmenu' || eventType === 'scroll' || eventType === 'selectionchange') {\n          if (wasNegotiated) {\n            shouldTerminate = false;\n          } else if (onResponderTerminationRequest != null) {\n            responderEvent.dispatchConfig.registrationName = 'onResponderTerminationRequest';\n\n            if (onResponderTerminationRequest(responderEvent) === false) {\n              shouldTerminate = false;\n            }\n          }\n        }\n\n        if (shouldTerminate) {\n          if (onResponderTerminate != null) {\n            responderEvent.dispatchConfig.registrationName = 'onResponderTerminate';\n            onResponderTerminate(responderEvent);\n          }\n\n          changeCurrentResponder(emptyResponder);\n          isEmulatingMouseEvents = false;\n          trackedTouchCount = 0;\n        }\n      }\n    }\n  }\n}\n\nfunction findWantsResponder(eventPaths, domEvent, responderEvent) {\n  var shouldSetCallbacks = shouldSetResponderEvents[domEvent.type];\n\n  if (shouldSetCallbacks != null) {\n    var idPath = eventPaths.idPath,\n        nodePath = eventPaths.nodePath;\n    var shouldSetCallbackCaptureName = shouldSetCallbacks[0];\n    var shouldSetCallbackBubbleName = shouldSetCallbacks[1];\n    var bubbles = shouldSetCallbacks[2].bubbles;\n\n    var check = function check(id, node, callbackName) {\n      var config = getResponderConfig(id);\n      var shouldSetCallback = config[callbackName];\n\n      if (shouldSetCallback != null) {\n        responderEvent.currentTarget = node;\n\n        if (shouldSetCallback(responderEvent) === true) {\n          var prunedIdPath = idPath.slice(idPath.indexOf(id));\n          return {\n            id: id,\n            node: node,\n            idPath: prunedIdPath\n          };\n        }\n      }\n    };\n\n    for (var i = idPath.length - 1; i >= 0; i--) {\n      var id = idPath[i];\n      var node = nodePath[i];\n      var result = check(id, node, shouldSetCallbackCaptureName);\n\n      if (result != null) {\n        return result;\n      }\n\n      if (responderEvent.isPropagationStopped() === true) {\n        return;\n      }\n    }\n\n    if (bubbles) {\n      for (var _i = 0; _i < idPath.length; _i++) {\n        var _id = idPath[_i];\n        var _node = nodePath[_i];\n\n        var _result = check(_id, _node, shouldSetCallbackBubbleName);\n\n        if (_result != null) {\n          return _result;\n        }\n\n        if (responderEvent.isPropagationStopped() === true) {\n          return;\n        }\n      }\n    } else {\n      var _id2 = idPath[0];\n      var _node2 = nodePath[0];\n      var target = domEvent.target;\n\n      if (target === _node2) {\n        return check(_id2, _node2, shouldSetCallbackBubbleName);\n      }\n    }\n  }\n}\n\nfunction attemptTransfer(responderEvent, wantsResponder) {\n  var _currentResponder2 = currentResponder,\n      currentId = _currentResponder2.id,\n      currentNode = _currentResponder2.node;\n  var id = wantsResponder.id,\n      node = wantsResponder.node;\n\n  var _getResponderConfig2 = getResponderConfig(id),\n      onResponderGrant = _getResponderConfig2.onResponderGrant,\n      onResponderReject = _getResponderConfig2.onResponderReject;\n\n  responderEvent.bubbles = false;\n  responderEvent.cancelable = false;\n  responderEvent.currentTarget = node;\n\n  if (currentId == null) {\n    if (onResponderGrant != null) {\n      responderEvent.currentTarget = node;\n      responderEvent.dispatchConfig.registrationName = 'onResponderGrant';\n      onResponderGrant(responderEvent);\n    }\n\n    changeCurrentResponder(wantsResponder);\n  } else {\n    var _getResponderConfig3 = getResponderConfig(currentId),\n        onResponderTerminate = _getResponderConfig3.onResponderTerminate,\n        onResponderTerminationRequest = _getResponderConfig3.onResponderTerminationRequest;\n\n    var allowTransfer = true;\n\n    if (onResponderTerminationRequest != null) {\n      responderEvent.currentTarget = currentNode;\n      responderEvent.dispatchConfig.registrationName = 'onResponderTerminationRequest';\n\n      if (onResponderTerminationRequest(responderEvent) === false) {\n        allowTransfer = false;\n      }\n    }\n\n    if (allowTransfer) {\n      if (onResponderTerminate != null) {\n        responderEvent.currentTarget = currentNode;\n        responderEvent.dispatchConfig.registrationName = 'onResponderTerminate';\n        onResponderTerminate(responderEvent);\n      }\n\n      if (onResponderGrant != null) {\n        responderEvent.currentTarget = node;\n        responderEvent.dispatchConfig.registrationName = 'onResponderGrant';\n        onResponderGrant(responderEvent);\n      }\n\n      changeCurrentResponder(wantsResponder);\n    } else {\n      if (onResponderReject != null) {\n        responderEvent.currentTarget = node;\n        responderEvent.dispatchConfig.registrationName = 'onResponderReject';\n        onResponderReject(responderEvent);\n      }\n    }\n  }\n}\n\nvar documentEventsCapturePhase = ['blur', 'scroll'];\nvar documentEventsBubblePhase = ['mousedown', 'mousemove', 'mouseup', 'dragstart', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'contextmenu', 'select', 'selectionchange'];\nexport function attachListeners() {\n  if (canUseDOM && window.__reactResponderSystemActive == null) {\n    window.addEventListener('blur', eventListener);\n    documentEventsBubblePhase.forEach(function (eventType) {\n      document.addEventListener(eventType, eventListener);\n    });\n    documentEventsCapturePhase.forEach(function (eventType) {\n      document.addEventListener(eventType, eventListener, true);\n    });\n    window.__reactResponderSystemActive = true;\n  }\n}\nexport function addNode(id, node, config) {\n  setResponderId(node, id);\n  responderListenersMap.set(id, config);\n}\nexport function removeNode(id) {\n  if (currentResponder.id === id) {\n    terminateResponder();\n  }\n\n  if (responderListenersMap.has(id)) {\n    responderListenersMap.delete(id);\n  }\n}\nexport function terminateResponder() {\n  var _currentResponder3 = currentResponder,\n      id = _currentResponder3.id,\n      node = _currentResponder3.node;\n\n  if (id != null && node != null) {\n    var _getResponderConfig4 = getResponderConfig(id),\n        onResponderTerminate = _getResponderConfig4.onResponderTerminate;\n\n    if (onResponderTerminate != null) {\n      var event = createResponderEvent({});\n      event.currentTarget = node;\n      onResponderTerminate(event);\n    }\n\n    changeCurrentResponder(emptyResponder);\n  }\n\n  isEmulatingMouseEvents = false;\n  trackedTouchCount = 0;\n}\nexport function getResponderNode() {\n  return currentResponder.node;\n}","map":{"version":3,"sources":["C:/Users/Jovan Zuniga/Desktop/COVID-NineTeam/node_modules/react-native-web/src/modules/useResponderEvents/ResponderSystem.js"],"names":["canUseDOM","createResponderEvent","isCancelish","isEndish","isMoveish","isScroll","isSelectionChange","isStartish","getLowestCommonAncestor","getResponderPaths","hasTargetTouches","hasValidSelection","isPrimaryPointerDown","setResponderId","ResponderTouchHistoryStore","emptyObject","startRegistration","bubbles","moveRegistration","scrollRegistration","shouldSetResponderEvents","touchstart","mousedown","touchmove","mousemove","scroll","emptyResponder","id","idPath","node","responderListenersMap","Map","isEmulatingMouseEvents","trackedTouchCount","currentResponder","changeCurrentResponder","responder","getResponderConfig","config","get","eventListener","domEvent","eventType","type","eventTarget","target","isStartEvent","isMoveEvent","isEndEvent","isScrollEvent","isSelectionChangeEvent","responderEvent","touches","length","recordTouchTrack","nativeEvent","eventPaths","wasNegotiated","wantsResponder","currentResponderIdPath","eventIdPath","lowestCommonAncestor","indexOfLowestCommonAncestor","indexOf","index","slice","nodePath","findWantsResponder","attemptTransfer","onResponderStart","onResponderMove","onResponderEnd","onResponderRelease","onResponderTerminate","onResponderTerminationRequest","cancelable","currentTarget","dispatchConfig","registrationName","isTerminateEvent","window","contains","relatedTarget","isReleaseEvent","shouldTerminate","shouldSetCallbacks","shouldSetCallbackCaptureName","shouldSetCallbackBubbleName","check","callbackName","shouldSetCallback","prunedIdPath","i","result","isPropagationStopped","currentId","currentNode","onResponderGrant","onResponderReject","allowTransfer","documentEventsCapturePhase","documentEventsBubblePhase","attachListeners","__reactResponderSystemActive","addEventListener","forEach","document","addNode","set","removeNode","terminateResponder","has","delete","event","getResponderNode"],"mappings":"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","sourcesContent":["/**\r\n * Copyright (c) Nicolas Gallagher\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\n/**\r\n * RESPONDER EVENT SYSTEM\r\n *\r\n * A single, global \"interaction lock\" on views. For a view to be the \"responder\" means\r\n * that pointer interactions are exclusive to that view and none other. The \"interaction\r\n * lock\" can be transferred (only) to ancestors of the current \"responder\" as long as\r\n * pointers continue to be active.\r\n *\r\n * Responder being granted:\r\n *\r\n * A view can become the \"responder\" after the following events:\r\n *  * \"pointerdown\" (implemented using \"touchstart\", \"mousedown\")\r\n *  * \"pointermove\" (implemented using \"touchmove\", \"mousemove\")\r\n *  * \"scroll\" (while a pointer is down)\r\n *  * \"selectionchange\" (while a pointer is down)\r\n *\r\n * If nothing is already the \"responder\", the event propagates to (capture) and from\r\n * (bubble) the event target until a view returns `true` for\r\n * `on*ShouldSetResponder(Capture)`.\r\n *\r\n * If something is already the responder, the event propagates to (capture) and from\r\n * (bubble) the lowest common ancestor of the event target and the current \"responder\".\r\n * Then negotiation happens between the current \"responder\" and a view that wants to\r\n * become the \"responder\": see the timing diagram below.\r\n *\r\n * (NOTE: Scrolled views either automatically become the \"responder\" or release the\r\n * \"interaction lock\". A native scroll view that isn't built on top of the responder\r\n * system must result in the current \"responder\" being notified that it no longer has\r\n * the \"interaction lock\" - the native system has taken over.\r\n *\r\n * Responder being released:\r\n *\r\n * As soon as there are no more active pointers that *started* inside descendants\r\n * of the *current* \"responder\", an `onResponderRelease` event is dispatched to the\r\n * current \"responder\", and the responder lock is released.\r\n *\r\n * Typical sequence of events:\r\n *  * startShouldSetResponder\r\n *  * responderGrant/Reject\r\n *  * responderStart\r\n *  * responderMove\r\n *  * responderEnd\r\n *  * responderRelease\r\n */\r\n\r\n/*                                             Negotiation Performed\r\n                                             +-----------------------+\r\n                                            /                         \\\r\nProcess low level events to    +     Current Responder      +   wantsResponderID\r\ndetermine who to perform negot-|   (if any exists at all)   |\r\niation/transition              | Otherwise just pass through|\r\n-------------------------------+----------------------------+------------------+\r\nBubble to find first ID        |                            |\r\nto return true:wantsResponderID|                            |\r\n                               |                            |\r\n     +--------------+          |                            |\r\n     | onTouchStart |          |                            |\r\n     +------+-------+    none  |                            |\r\n            |            return|                            |\r\n+-----------v-------------+true| +------------------------+ |\r\n|onStartShouldSetResponder|----->| onResponderStart (cur) |<-----------+\r\n+-----------+-------------+    | +------------------------+ |          |\r\n            |                  |                            | +--------+-------+\r\n            | returned true for|       false:REJECT +-------->|onResponderReject\r\n            | wantsResponderID |                    |       | +----------------+\r\n            | (now attempt     | +------------------+-----+ |\r\n            |  handoff)        | | onResponder            | |\r\n            +------------------->|    TerminationRequest  | |\r\n                               | +------------------+-----+ |\r\n                               |                    |       | +----------------+\r\n                               |         true:GRANT +-------->|onResponderGrant|\r\n                               |                            | +--------+-------+\r\n                               | +------------------------+ |          |\r\n                               | | onResponderTerminate   |<-----------+\r\n                               | +------------------+-----+ |\r\n                               |                    |       | +----------------+\r\n                               |                    +-------->|onResponderStart|\r\n                               |                            | +----------------+\r\nBubble to find first ID        |                            |\r\nto return true:wantsResponderID|                            |\r\n                               |                            |\r\n     +-------------+           |                            |\r\n     | onTouchMove |           |                            |\r\n     +------+------+     none  |                            |\r\n            |            return|                            |\r\n+-----------v-------------+true| +------------------------+ |\r\n|onMoveShouldSetResponder |----->| onResponderMove (cur)  |<-----------+\r\n+-----------+-------------+    | +------------------------+ |          |\r\n            |                  |                            | +--------+-------+\r\n            | returned true for|       false:REJECT +-------->|onResponderReject\r\n            | wantsResponderID |                    |       | +----------------+\r\n            | (now attempt     | +------------------+-----+ |\r\n            |  handoff)        | |   onResponder          | |\r\n            +------------------->|      TerminationRequest| |\r\n                               | +------------------+-----+ |\r\n                               |                    |       | +----------------+\r\n                               |         true:GRANT +-------->|onResponderGrant|\r\n                               |                            | +--------+-------+\r\n                               | +------------------------+ |          |\r\n                               | |   onResponderTerminate |<-----------+\r\n                               | +------------------+-----+ |\r\n                               |                    |       | +----------------+\r\n                               |                    +-------->|onResponderMove |\r\n                               |                            | +----------------+\r\n                               |                            |\r\n                               |                            |\r\n      Some active touch started|                            |\r\n      inside current responder | +------------------------+ |\r\n      +------------------------->|      onResponderEnd    | |\r\n      |                        | +------------------------+ |\r\n  +---+---------+              |                            |\r\n  | onTouchEnd  |              |                            |\r\n  +---+---------+              |                            |\r\n      |                        | +------------------------+ |\r\n      +------------------------->|     onResponderEnd     | |\r\n      No active touches started| +-----------+------------+ |\r\n      inside current responder |             |              |\r\n                               |             v              |\r\n                               | +------------------------+ |\r\n                               | |    onResponderRelease  | |\r\n                               | +------------------------+ |\r\n                               |                            |\r\n                               +                            + */\r\n\r\nimport type { ResponderEvent } from './createResponderEvent';\r\n\r\nimport { canUseDOM } from 'fbjs/lib/ExecutionEnvironment';\r\nimport createResponderEvent from './createResponderEvent';\r\nimport {\r\n  isCancelish,\r\n  isEndish,\r\n  isMoveish,\r\n  isScroll,\r\n  isSelectionChange,\r\n  isStartish\r\n} from './ResponderEventTypes';\r\nimport {\r\n  getLowestCommonAncestor,\r\n  getResponderPaths,\r\n  hasTargetTouches,\r\n  hasValidSelection,\r\n  isPrimaryPointerDown,\r\n  setResponderId\r\n} from './utils';\r\nimport ResponderTouchHistoryStore from './ResponderTouchHistoryStore';\r\n\r\n/* ------------ TYPES ------------ */\r\n\r\ntype ResponderId = number;\r\n\r\ntype ActiveResponderInstance = {\r\n  id: ResponderId,\r\n  idPath: Array<number>,\r\n  node: any\r\n};\r\n\r\ntype EmptyResponderInstance = {\r\n  id: null,\r\n  idPath: null,\r\n  node: null\r\n};\r\n\r\ntype ResponderInstance = ActiveResponderInstance | EmptyResponderInstance;\r\n\r\nexport type ResponderConfig = {\r\n  // Direct responder events dispatched directly to responder. Do not bubble.\r\n  onResponderEnd?: ?(e: ResponderEvent) => void,\r\n  onResponderGrant?: ?(e: ResponderEvent) => void | boolean,\r\n  onResponderMove?: ?(e: ResponderEvent) => void,\r\n  onResponderRelease?: ?(e: ResponderEvent) => void,\r\n  onResponderReject?: ?(e: ResponderEvent) => void,\r\n  onResponderStart?: ?(e: ResponderEvent) => void,\r\n  onResponderTerminate?: ?(e: ResponderEvent) => void,\r\n  onResponderTerminationRequest?: ?(e: ResponderEvent) => boolean,\r\n  // On pointer down, should this element become the responder?\r\n  onStartShouldSetResponder?: ?(e: ResponderEvent) => boolean,\r\n  onStartShouldSetResponderCapture?: ?(e: ResponderEvent) => boolean,\r\n  // On pointer move, should this element become the responder?\r\n  onMoveShouldSetResponder?: ?(e: ResponderEvent) => boolean,\r\n  onMoveShouldSetResponderCapture?: ?(e: ResponderEvent) => boolean,\r\n  // On scroll, should this element become the responder? Do no bubble\r\n  onScrollShouldSetResponder?: ?(e: ResponderEvent) => boolean,\r\n  onScrollShouldSetResponderCapture?: ?(e: ResponderEvent) => boolean,\r\n  // On text selection change, should this element become the responder?\r\n  onSelectionChangeShouldSetResponder?: ?(e: ResponderEvent) => boolean,\r\n  onSelectionChangeShouldSetResponderCapture?: ?(e: ResponderEvent) => boolean\r\n};\r\n\r\nconst emptyObject = {};\r\n\r\n/* ------------ IMPLEMENTATION ------------ */\r\n\r\nconst startRegistration = [\r\n  'onStartShouldSetResponderCapture',\r\n  'onStartShouldSetResponder',\r\n  { bubbles: true }\r\n];\r\nconst moveRegistration = [\r\n  'onMoveShouldSetResponderCapture',\r\n  'onMoveShouldSetResponder',\r\n  { bubbles: true }\r\n];\r\nconst scrollRegistration = [\r\n  'onScrollShouldSetResponderCapture',\r\n  'onScrollShouldSetResponder',\r\n  { bubbles: false }\r\n];\r\nconst shouldSetResponderEvents = {\r\n  touchstart: startRegistration,\r\n  mousedown: startRegistration,\r\n  touchmove: moveRegistration,\r\n  mousemove: moveRegistration,\r\n  scroll: scrollRegistration\r\n};\r\n\r\nconst emptyResponder = { id: null, idPath: null, node: null };\r\nconst responderListenersMap = new Map();\r\n\r\nlet isEmulatingMouseEvents = false;\r\nlet trackedTouchCount = 0;\r\nlet currentResponder: ResponderInstance = {\r\n  id: null,\r\n  node: null,\r\n  idPath: null\r\n};\r\n\r\nfunction changeCurrentResponder(responder: ResponderInstance) {\r\n  currentResponder = responder;\r\n}\r\n\r\nfunction getResponderConfig(id: ResponderId): ResponderConfig | Object {\r\n  const config = responderListenersMap.get(id);\r\n  return config != null ? config : emptyObject;\r\n}\r\n\r\n/**\r\n * Process native events\r\n *\r\n * A single event listener is used to manage the responder system.\r\n * All pointers are tracked in the ResponderTouchHistoryStore. Native events\r\n * are interpreted in terms of the Responder System and checked to see if\r\n * the responder should be transferred. Each host node that is attached to\r\n * the Responder System has an ID, which is used to look up its associated\r\n * callbacks.\r\n */\r\nfunction eventListener(domEvent: any) {\r\n  const eventType = domEvent.type;\r\n  const eventTarget = domEvent.target;\r\n\r\n  /**\r\n   * Manage emulated events and early bailout.\r\n   * Since PointerEvent is not used yet (lack of support in older Safari), it's\r\n   * necessary to manually manage the mess of browser touch/mouse events.\r\n   * And bailout early for termination events when there is no active responder.\r\n   */\r\n\r\n  // Flag when browser may produce emulated events\r\n  if (eventType === 'touchstart') {\r\n    isEmulatingMouseEvents = true;\r\n  }\r\n  // Remove flag when browser will not produce emulated events\r\n  if (eventType === 'touchmove' || trackedTouchCount > 1) {\r\n    isEmulatingMouseEvents = false;\r\n  }\r\n  // Ignore various events in particular circumstances\r\n  if (\r\n    // Ignore browser emulated mouse events\r\n    (eventType === 'mousedown' && isEmulatingMouseEvents) ||\r\n    (eventType === 'mousemove' && isEmulatingMouseEvents) ||\r\n    // Ignore mousemove if a mousedown didn't occur first\r\n    (eventType === 'mousemove' && trackedTouchCount < 1)\r\n  ) {\r\n    return;\r\n  }\r\n  // Remove flag after emulated events are finished\r\n  if (isEmulatingMouseEvents && eventType === 'mouseup') {\r\n    if (trackedTouchCount === 0) {\r\n      isEmulatingMouseEvents = false;\r\n    }\r\n    return;\r\n  }\r\n\r\n  const isStartEvent = isStartish(eventType) && isPrimaryPointerDown(domEvent);\r\n  const isMoveEvent = isMoveish(eventType);\r\n  const isEndEvent = isEndish(eventType);\r\n  const isScrollEvent = isScroll(eventType);\r\n  const isSelectionChangeEvent = isSelectionChange(eventType);\r\n  const responderEvent = createResponderEvent(domEvent);\r\n\r\n  /**\r\n   * Record the state of active pointers\r\n   */\r\n\r\n  if (isStartEvent || isMoveEvent || isEndEvent) {\r\n    if (domEvent.touches) {\r\n      trackedTouchCount = domEvent.touches.length;\r\n    } else {\r\n      if (isStartEvent) {\r\n        trackedTouchCount = 1;\r\n      } else if (isEndEvent) {\r\n        trackedTouchCount = 0;\r\n      }\r\n    }\r\n    ResponderTouchHistoryStore.recordTouchTrack(eventType, responderEvent.nativeEvent);\r\n  }\r\n\r\n  /**\r\n   * Responder System logic\r\n   */\r\n\r\n  let eventPaths = getResponderPaths(domEvent);\r\n  let wasNegotiated = false;\r\n  let wantsResponder;\r\n\r\n  // If an event occured that might change the current responder...\r\n  if (isStartEvent || isMoveEvent || (isScrollEvent && trackedTouchCount > 0)) {\r\n    // If there is already a responder, prune the event paths to the lowest common ancestor\r\n    // of the existing responder and deepest target of the event.\r\n    const currentResponderIdPath = currentResponder.idPath;\r\n    const eventIdPath = eventPaths.idPath;\r\n\r\n    if (currentResponderIdPath != null && eventIdPath != null) {\r\n      const lowestCommonAncestor = getLowestCommonAncestor(currentResponderIdPath, eventIdPath);\r\n      if (lowestCommonAncestor != null) {\r\n        const indexOfLowestCommonAncestor = eventIdPath.indexOf(lowestCommonAncestor);\r\n        // Skip the current responder so it doesn't receive unexpected \"shouldSet\" events.\r\n        const index =\r\n          indexOfLowestCommonAncestor + (lowestCommonAncestor === currentResponder.id ? 1 : 0);\r\n        eventPaths = {\r\n          idPath: eventIdPath.slice(index),\r\n          nodePath: eventPaths.nodePath.slice(index)\r\n        };\r\n      } else {\r\n        eventPaths = null;\r\n      }\r\n    }\r\n\r\n    if (eventPaths != null) {\r\n      // If a node wants to become the responder, attempt to transfer.\r\n      wantsResponder = findWantsResponder(eventPaths, domEvent, responderEvent);\r\n      if (wantsResponder != null) {\r\n        // Sets responder if none exists, or negotates with existing responder.\r\n        attemptTransfer(responderEvent, wantsResponder);\r\n        wasNegotiated = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  // If there is now a responder, invoke its callbacks for the lifecycle of the gesture.\r\n  if (currentResponder.id != null && currentResponder.node != null) {\r\n    const { id, node } = currentResponder;\r\n    const {\r\n      onResponderStart,\r\n      onResponderMove,\r\n      onResponderEnd,\r\n      onResponderRelease,\r\n      onResponderTerminate,\r\n      onResponderTerminationRequest\r\n    } = getResponderConfig(id);\r\n\r\n    responderEvent.bubbles = false;\r\n    responderEvent.cancelable = false;\r\n    responderEvent.currentTarget = node;\r\n\r\n    // Start\r\n    if (isStartEvent) {\r\n      if (onResponderStart != null) {\r\n        responderEvent.dispatchConfig.registrationName = 'onResponderStart';\r\n        onResponderStart(responderEvent);\r\n      }\r\n    }\r\n    // Move\r\n    else if (isMoveEvent) {\r\n      if (onResponderMove != null) {\r\n        responderEvent.dispatchConfig.registrationName = 'onResponderMove';\r\n        onResponderMove(responderEvent);\r\n      }\r\n    } else {\r\n      const isTerminateEvent =\r\n        isCancelish(eventType) ||\r\n        // native context menu\r\n        eventType === 'contextmenu' ||\r\n        // window blur\r\n        (eventType === 'blur' && eventTarget === window) ||\r\n        // responder (or ancestors) blur\r\n        (eventType === 'blur' && eventTarget.contains(node) && domEvent.relatedTarget !== node) ||\r\n        // native scroll without using a pointer\r\n        (isScrollEvent && trackedTouchCount === 0) ||\r\n        // native scroll on node that is parent of the responder (allow siblings to scroll)\r\n        (isScrollEvent && eventTarget.contains(node) && eventTarget !== node) ||\r\n        // native select/selectionchange on node\r\n        (isSelectionChangeEvent && hasValidSelection(domEvent));\r\n\r\n      const isReleaseEvent =\r\n        isEndEvent && !isTerminateEvent && !hasTargetTouches(node, domEvent.touches);\r\n\r\n      // End\r\n      if (isEndEvent) {\r\n        if (onResponderEnd != null) {\r\n          responderEvent.dispatchConfig.registrationName = 'onResponderEnd';\r\n          onResponderEnd(responderEvent);\r\n        }\r\n      }\r\n      // Release\r\n      if (isReleaseEvent) {\r\n        if (onResponderRelease != null) {\r\n          responderEvent.dispatchConfig.registrationName = 'onResponderRelease';\r\n          onResponderRelease(responderEvent);\r\n        }\r\n        changeCurrentResponder(emptyResponder);\r\n      }\r\n      // Terminate\r\n      if (isTerminateEvent) {\r\n        let shouldTerminate = true;\r\n\r\n        // Responders can still avoid termination but only for these events.\r\n        if (\r\n          eventType === 'contextmenu' ||\r\n          eventType === 'scroll' ||\r\n          eventType === 'selectionchange'\r\n        ) {\r\n          // Only call this function is it wasn't already called during negotiation.\r\n          if (wasNegotiated) {\r\n            shouldTerminate = false;\r\n          } else if (onResponderTerminationRequest != null) {\r\n            responderEvent.dispatchConfig.registrationName = 'onResponderTerminationRequest';\r\n            if (onResponderTerminationRequest(responderEvent) === false) {\r\n              shouldTerminate = false;\r\n            }\r\n          }\r\n        }\r\n\r\n        if (shouldTerminate) {\r\n          if (onResponderTerminate != null) {\r\n            responderEvent.dispatchConfig.registrationName = 'onResponderTerminate';\r\n            onResponderTerminate(responderEvent);\r\n          }\r\n          changeCurrentResponder(emptyResponder);\r\n          isEmulatingMouseEvents = false;\r\n          trackedTouchCount = 0;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Walk the event path to/from the target node. At each node, stop and call the\r\n * relevant \"shouldSet\" functions for the given event type. If any of those functions\r\n * call \"stopPropagation\" on the event, stop searching for a responder.\r\n */\r\nfunction findWantsResponder(eventPaths, domEvent, responderEvent) {\r\n  const shouldSetCallbacks = shouldSetResponderEvents[(domEvent.type: any)]; // for Flow\r\n\r\n  if (shouldSetCallbacks != null) {\r\n    const { idPath, nodePath } = eventPaths;\r\n\r\n    const shouldSetCallbackCaptureName = shouldSetCallbacks[0];\r\n    const shouldSetCallbackBubbleName = shouldSetCallbacks[1];\r\n    const { bubbles } = shouldSetCallbacks[2];\r\n\r\n    const check = function (id, node, callbackName) {\r\n      const config = getResponderConfig(id);\r\n      const shouldSetCallback = config[callbackName];\r\n      if (shouldSetCallback != null) {\r\n        responderEvent.currentTarget = node;\r\n        if (shouldSetCallback(responderEvent) === true) {\r\n          // Start the path from the potential responder\r\n          const prunedIdPath = idPath.slice(idPath.indexOf(id));\r\n          return { id, node, idPath: prunedIdPath };\r\n        }\r\n      }\r\n    };\r\n\r\n    // capture\r\n    for (let i = idPath.length - 1; i >= 0; i--) {\r\n      const id = idPath[i];\r\n      const node = nodePath[i];\r\n      const result = check(id, node, shouldSetCallbackCaptureName);\r\n      if (result != null) {\r\n        return result;\r\n      }\r\n      if (responderEvent.isPropagationStopped() === true) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    // bubble\r\n    if (bubbles) {\r\n      for (let i = 0; i < idPath.length; i++) {\r\n        const id = idPath[i];\r\n        const node = nodePath[i];\r\n        const result = check(id, node, shouldSetCallbackBubbleName);\r\n        if (result != null) {\r\n          return result;\r\n        }\r\n        if (responderEvent.isPropagationStopped() === true) {\r\n          return;\r\n        }\r\n      }\r\n    } else {\r\n      const id = idPath[0];\r\n      const node = nodePath[0];\r\n      const target = domEvent.target;\r\n      if (target === node) {\r\n        return check(id, node, shouldSetCallbackBubbleName);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Attempt to transfer the responder.\r\n */\r\nfunction attemptTransfer(responderEvent: ResponderEvent, wantsResponder: ActiveResponderInstance) {\r\n  const { id: currentId, node: currentNode } = currentResponder;\r\n  const { id, node } = wantsResponder;\r\n\r\n  const { onResponderGrant, onResponderReject } = getResponderConfig(id);\r\n\r\n  responderEvent.bubbles = false;\r\n  responderEvent.cancelable = false;\r\n  responderEvent.currentTarget = node;\r\n\r\n  // Set responder\r\n  if (currentId == null) {\r\n    if (onResponderGrant != null) {\r\n      responderEvent.currentTarget = node;\r\n      responderEvent.dispatchConfig.registrationName = 'onResponderGrant';\r\n      onResponderGrant(responderEvent);\r\n    }\r\n    changeCurrentResponder(wantsResponder);\r\n  }\r\n  // Negotiate with current responder\r\n  else {\r\n    const { onResponderTerminate, onResponderTerminationRequest } = getResponderConfig(currentId);\r\n\r\n    let allowTransfer = true;\r\n    if (onResponderTerminationRequest != null) {\r\n      responderEvent.currentTarget = currentNode;\r\n      responderEvent.dispatchConfig.registrationName = 'onResponderTerminationRequest';\r\n      if (onResponderTerminationRequest(responderEvent) === false) {\r\n        allowTransfer = false;\r\n      }\r\n    }\r\n\r\n    if (allowTransfer) {\r\n      // Terminate existing responder\r\n      if (onResponderTerminate != null) {\r\n        responderEvent.currentTarget = currentNode;\r\n        responderEvent.dispatchConfig.registrationName = 'onResponderTerminate';\r\n        onResponderTerminate(responderEvent);\r\n      }\r\n      // Grant next responder\r\n      if (onResponderGrant != null) {\r\n        responderEvent.currentTarget = node;\r\n        responderEvent.dispatchConfig.registrationName = 'onResponderGrant';\r\n        onResponderGrant(responderEvent);\r\n      }\r\n      changeCurrentResponder(wantsResponder);\r\n    } else {\r\n      // Reject responder request\r\n      if (onResponderReject != null) {\r\n        responderEvent.currentTarget = node;\r\n        responderEvent.dispatchConfig.registrationName = 'onResponderReject';\r\n        onResponderReject(responderEvent);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/* ------------ PUBLIC API ------------ */\r\n\r\n/**\r\n * Attach Listeners\r\n *\r\n * Use native events as ReactDOM doesn't have a non-plugin API to implement\r\n * this system.\r\n */\r\nconst documentEventsCapturePhase = ['blur', 'scroll'];\r\nconst documentEventsBubblePhase = [\r\n  // mouse\r\n  'mousedown',\r\n  'mousemove',\r\n  'mouseup',\r\n  'dragstart',\r\n  // touch\r\n  'touchstart',\r\n  'touchmove',\r\n  'touchend',\r\n  'touchcancel',\r\n  // other\r\n  'contextmenu',\r\n  'select',\r\n  'selectionchange'\r\n];\r\nexport function attachListeners() {\r\n  if (canUseDOM && window.__reactResponderSystemActive == null) {\r\n    window.addEventListener('blur', eventListener);\r\n    documentEventsBubblePhase.forEach((eventType) => {\r\n      document.addEventListener(eventType, eventListener);\r\n    });\r\n    documentEventsCapturePhase.forEach((eventType) => {\r\n      document.addEventListener(eventType, eventListener, true);\r\n    });\r\n    window.__reactResponderSystemActive = true;\r\n  }\r\n}\r\n\r\n/**\r\n * Register a node with the ResponderSystem.\r\n */\r\nexport function addNode(id: ResponderId, node: any, config: ResponderConfig) {\r\n  setResponderId(node, id);\r\n  responderListenersMap.set(id, config);\r\n}\r\n\r\n/**\r\n * Unregister a node with the ResponderSystem.\r\n */\r\nexport function removeNode(id: ResponderId) {\r\n  if (currentResponder.id === id) {\r\n    terminateResponder();\r\n  }\r\n  if (responderListenersMap.has(id)) {\r\n    responderListenersMap.delete(id);\r\n  }\r\n}\r\n\r\n/**\r\n * Allow the current responder to be terminated from within components to support\r\n * more complex requirements, such as use with other React libraries for working\r\n * with scroll views, input views, etc.\r\n */\r\nexport function terminateResponder() {\r\n  const { id, node } = currentResponder;\r\n  if (id != null && node != null) {\r\n    const { onResponderTerminate } = getResponderConfig(id);\r\n    if (onResponderTerminate != null) {\r\n      const event = createResponderEvent({});\r\n      event.currentTarget = node;\r\n      onResponderTerminate(event);\r\n    }\r\n    changeCurrentResponder(emptyResponder);\r\n  }\r\n  isEmulatingMouseEvents = false;\r\n  trackedTouchCount = 0;\r\n}\r\n\r\n/**\r\n * Allow unit tests to inspect the current responder in the system.\r\n * FOR TESTING ONLY.\r\n */\r\nexport function getResponderNode(): any {\r\n  return currentResponder.node;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}